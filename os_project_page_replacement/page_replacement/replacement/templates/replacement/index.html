{% extends "replacement/layout.html" %} {% block result %}


<h3 data-aos="fade-right" style="text-align: center;font-weight: bold;">算法是如何工作的
</h3>
<div class="container" data-aos="fade-up">
    <p>
        <br> 在所有算法中，如果发生页面错误，我们首先检查帧是否有任何空闲空间。如果是这样，我们只需将新页面附加到框架中。如果没有空闲空间，我们根据不同的算法采取不同的方法.
        <br>
        <br>
        <b>先进先出 (FIFO)</b>
        <br> &nbsp;&nbsp;&nbsp;对于FIFO算法，我们只需按顺序删除帧中的页面。把它想象成一个队列。 例如，当一个新人进入队列时，他们会排在队列的后面。 该算法以类似的方式工作，如果帧已满并且需要新页面，它将用队列顶部的“最旧”页面替换新页面。 然后，在替换后，框架中的下一页将被视为队列中“最旧”的页.
        <br>
        <hr>
        <b>最近最少使用 (LRU)</b>
        <br> &nbsp;&nbsp;&nbsp;对于最近最少使用的算法，它的工作原理与FIFO非常相似。然而，这一次，当页面被引用并位于帧中时， 页面从其当前位置删除，然后基本上在帧的末尾排队。如果新页面被引用并且不在框架中，我们只需删除 位于帧末尾的页面，因为它是最近使用最少的页面。我们知道该页面是最近使用最少的页面，因为引用的页面总是 再次排队，不管它是否出现在画面中.
        <br>
        <hr>
        <b>最佳页面替换(OPT)</b>
        <br> &nbsp;&nbsp;&nbsp;在这个算法中，我们着眼于未来或“预测”。如果发生页面错误，我们只需查看页面引用的顺序，看看帧中的哪个页面最长时间不会被使用。尽管该算法在所有算法中页面错误率最低，但由于很难预测未来，因此并不实用.
        <br>
        <hr>
    </p>
</div>

{% endblock %}