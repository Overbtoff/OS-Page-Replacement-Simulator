{% extends "replacement/layout.html" %} {% block result %}


<h3 data-aos="fade-right" style="text-align: center;font-weight: bold;">算法是如何工作的
</h3>
<div class="container" data-aos="fade-up">
    <p>
        <br> 在所有算法中，如果发生页面错误，我们首先检查帧是否有任何空闲空间。如果是这样，我们只需将新页面附加到框架中。如果没有空闲空间，我们根据不同的算法采取不同的方法.
        <br>
        <br>
        <b>先进先出(FIFO)</b>
        <br> &nbsp;&nbsp;&nbsp;对于FIFO算法，我们只需按顺序删除帧中的页面。把它想象成一个队列。 例如，当一个新页面进入队列时，他们会排在队列的后面。 该算法以类似的方式工作，如果帧已满并且需要新页面，它将用队列顶部的“最旧”页面替换新页面。 然后，在替换后，框架中的下一页将被视为队列中“最旧”的页。即一个管道中先进的页面一定会先出
        <br>    
        <hr>
        <b>最近最久未使用(LRU)</b>
        <br> &nbsp;&nbsp;&nbsp;对于最近最少使用的算法，它的工作原理与FIFO非常相似。然而，这一次，当页面被引用并位于帧中时，页面从其当前位置删除，然后基本上在帧的末尾排队。如果新页面被引用并且不在框架中，我们只需删除位于帧末尾的页面，因为它是最近使用最少的页面。我们知道该页面是最近使用最少的页面，因为引用的页面总是再次排队，不管它是否出现在画面中.
        <br>
        <hr>
        <b>最少使用（LFU）</b>
        <br> &nbsp;&nbsp;&nbsp;该置换算法选择在最近时期使用最少的页面作为淘汰页，它基于页面的访问频率每次访问缓存时，增加该数据的访问次数计数。当缓存满时，删除使用频率最低的数据项。LFU算法会记录每个缓存块的使用次数，并按照使用次数从低到高排序。当缓存达到容量上限时，选择使用次数最少的缓存块进行清除。
        <br>
        <hr>
        <b>最佳页面替换(OPT)</b>
        <br> &nbsp;&nbsp;&nbsp;在这个算法中，我们着眼于未来或“预测”。如果发生页面错误，我们只需查看页面引用的顺序，看看帧中的哪个页面最长时间不会被使用。尽管该算法在所有算法中页面错误率最低，但由于很难预测未来，因此并不实用。
        <br>
        <hr>
    </p>
</div>

{% endblock %}